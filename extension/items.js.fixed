// Items-related functionality for League of Legends Helper extension

// Requires utils.js to be loaded first

class ItemsManager {
  constructor() {
    // Get references to DOM elements - Items
    this.itemsList = document.getElementById('items-list');
    this.itemsLoadingElement = document.getElementById('loading-items');
    this.itemsErrorElement = document.getElementById('error-items');
    this.itemsNoResultsElement = document.getElementById('no-results-items');
    this.itemDetail = document.getElementById('item-detail');
    this.backToItemsButton = document.getElementById('back-to-items-button');
    this.resetSearchItems = document.getElementById('reset-search-items');
    
    // Initialize state
    this.allItems = []; // Store all items from API
    this.itemsByTier = {}; // Store items grouped by tier
    this.currentItem = null; // Current item being viewed
    this.currentTier = 'all'; // Current tier filter for items
    this.API_BASE_URL = window.LOLUtils.API_BASE_URL;
    
    // Initialize filter state
    this.itemFilter = {
      searchText: '',
      activeTags: new Set(),
      activeStats: new Set()
    };
    
    // Set up event handlers
    this._setupEventHandlers();
    
    // Set up observer for item detail
    this._setupObserver();
  }
  
  _setupEventHandlers() {
    // Set up filter tabs
    const filterTabs = document.querySelectorAll('.filter-tab');
    filterTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Get the tab ID
        const tabId = tab.getAttribute('data-tab');
        
        // Update active state for tabs
        filterTabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Update active state for panes
        document.querySelectorAll('.filter-pane').forEach(pane => pane.classList.remove('active'));
        document.getElementById(`${tabId}-pane`).classList.add('active');
      });
    });
    
    // Set up tier filter buttons
    const tierButtons = document.querySelectorAll('.tier-button');
    tierButtons.forEach(button => {
      button.addEventListener('click', () => {
        // Get the tier from the button
        const tier = button.getAttribute('data-tier');
        
        // Update active state
        tierButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        
        // Update current tier and redisplay items
        this.currentTier = tier;
        this.updateActiveFilters();
        this.displayItems();
      });
    });
    
    // Set up stat filter buttons
    const statFilters = document.querySelectorAll('.stat-filter');
    statFilters.forEach(button => {
      button.addEventListener('click', () => {
        // Get the stat from the button
        const stat = button.getAttribute('data-stat');
        
        // Toggle active state
        button.classList.toggle('active');
        
        // Update filter state
        if (this.itemFilter.activeStats.has(stat)) {
          this.itemFilter.activeStats.delete(stat);
        } else {
          this.itemFilter.activeStats.add(stat);
        }
        
        this.updateActiveFilters();
        this.displayItems();
      });
    });
    
    // Set up back button for items
    if (this.backToItemsButton) {
      this.backToItemsButton.addEventListener('click', () => this.showItemsList());
    }
    
    // Set up item search clear button
    const searchClear = document.getElementById('item-search-clear');
    if (searchClear) {
      searchClear.addEventListener('click', () => {
        const searchInput = document.getElementById('item-search-input');
        if (searchInput) {
          searchInput.value = '';
          this.itemFilter.searchText = '';
          searchClear.style.display = 'none';
          
          this.updateActiveFilters();
          this.displayItems();
          
          // Focus back on search input
          searchInput.focus();
        }
      });
    }
    
    // Reset search button for items
    if (this.resetSearchItems) {
      this.resetSearchItems.addEventListener('click', () => {
        this.resetAllFilters();
      });
    }
    
    // Clear all filters button
    const clearFiltersButton = document.getElementById('clear-item-filters');
    if (clearFiltersButton) {
      clearFiltersButton.addEventListener('click', () => {
        this.resetAllFilters();
      });
    }
  }
  
  // Update the active filters display
  updateActiveFilters() {
    const activeFiltersList = document.getElementById('active-filters-list');
    if (!activeFiltersList) return;
    
    // Build list of active filters
    const activeFilters = [];
    
    // Add tier filter
    if (this.currentTier !== 'all') {
      activeFilters.push(`Tier: ${this.getTierDisplayName(this.currentTier).replace(' Items', '')}`);
    }
    
    // Add stat filters
    if (this.itemFilter.activeStats.size > 0) {
      const statNames = {
        'ad': 'Attack Damage',
        'ap': 'Ability Power',
        'armor': 'Armor',
        'mr': 'Magic Resist',
        'hp': 'Health',
        'mana': 'Mana',
        'as': 'Attack Speed',
        'crit': 'Critical',
        'ms': 'Movement',
        'utility': 'Utility'
      };
      
      this.itemFilter.activeStats.forEach(stat => {
        activeFilters.push(`Stat: ${statNames[stat] || stat}`);
      });
    }
    
    // Add search text
    if (this.itemFilter.searchText) {
      activeFilters.push(`Search: "${this.itemFilter.searchText}"`);
    }
    
    // Update the display
    if (activeFilters.length > 0) {
      activeFiltersList.innerHTML = activeFilters.map(filter => 
        `<span class="filter-tag">${filter}</span>`
      ).join('');
    } else {
      activeFiltersList.innerHTML = 'None';
    }
  }
  
  // Reset all filters
  resetAllFilters() {
    // Reset search input
    const searchInput = document.getElementById('item-search-input');
    if (searchInput) {
      searchInput.value = '';
    }
    this.itemFilter.searchText = '';
    
    // Reset tier filter
    const tierButtons = document.querySelectorAll('.tier-button');
    tierButtons.forEach(btn => btn.classList.remove('active'));
    const allTierButton = document.querySelector('.tier-button[data-tier="all"]');
    if (allTierButton) {
      allTierButton.classList.add('active');
    }
    this.currentTier = 'all';
    
    // Reset stat filters
    this.itemFilter.activeStats.clear();
    const statFilters = document.querySelectorAll('.stat-filter');
    statFilters.forEach(btn => btn.classList.remove('active'));
    
    // Update UI and display
    this.updateActiveFilters();
    this.displayItems();
  }
  
  // Set up a mutation observer to detect when item detail is shown
  _setupObserver() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.target.id === 'item-detail' && 
            window.getComputedStyle(mutation.target).display === 'block') {
          console.log("Item detail displayed - fixing tabs");
          window.LOLUtils.fixItemDetailTabs();
        }
      });
    });
    
    // Start observing the item detail element
    if (this.itemDetail) {
      observer.observe(this.itemDetail, { 
        attributes: true,
        attributeFilter: ['style']
      });
      console.log("Observer set up for item detail");
    }
  }

  // Function to fetch items data with caching
  async fetchItems() {
    try {
      // Show loading state
      this.itemsLoadingElement.style.display = 'block';
      this.itemsErrorElement.style.display = 'none';
      this.itemsNoResultsElement.style.display = 'none';
      
      // Check if we have cached items data
      const items = await window.LOLUtils.getCachedItems();
      
      if (items) {
        // Use cached data
        console.log('Using cached items data');
        this.allItems = items;
        this.processItems();
        return;
      }
      
      // No cache or expired cache, fetch from API
      console.log('Fetching items from API (all pages)');
      
      // Fetch the first page to get total count
      const firstPageResponse = await fetch(`${this.API_BASE_URL}/items?limit=100&page=1`);
      
      if (!firstPageResponse.ok) {
        throw new Error(`API request failed with status ${firstPageResponse.status}`);
      }
      
      const firstPageData = await firstPageResponse.json();
      const totalItems = firstPageData.total || 0;
      
      // Calculate how many pages we need to fetch
      const itemsPerPage = 100;
      const totalPages = Math.ceil(totalItems / itemsPerPage);
      
      console.log(`Total items: ${totalItems}, pages needed: ${totalPages}`);
      
      // Start with items from first page
      let allItemsAcrossPages = [];
      
      // Add items from first page
      if (firstPageData && firstPageData.tiers) {
        allItemsAcrossPages = firstPageData.tiers.flatMap(tier => tier.items || []);
      }
      
      // Fetch additional pages if needed
      const additionalPagePromises = [];
      for (let page = 2; page <= totalPages; page++) {
        console.log(`Fetching page ${page} of ${totalPages}`);
        additionalPagePromises.push(
          fetch(`${this.API_BASE_URL}/items?limit=100&page=${page}`)
            .then(response => {
              if (!response.ok) {
                throw new Error(`API request for page ${page} failed with status ${response.status}`);
              }
              return response.json();
            })
            .then(pageData => {
              if (pageData && pageData.tiers) {
                // Extract items from this page
                const pageItems = pageData.tiers.flatMap(tier => tier.items || []);
                return pageItems;
              }
              return [];
            })
        );
      }
      
      // Wait for all additional pages to load
      const additionalPagesResults = await Promise.all(additionalPagePromises);
      
      // Combine all items from all pages
      additionalPagesResults.forEach(pageItems => {
        allItemsAcrossPages = allItemsAcrossPages.concat(pageItems);
      });
      
      // Hide loading state
      this.itemsLoadingElement.style.display = 'none';
      
      // Store all items
      this.allItems = allItemsAcrossPages;
      
      console.log(`Processed ${this.allItems.length} items from all API pages`);
      
      // Process and display items
      this.processItems();
      
      // Save to cache
      await window.LOLUtils.cacheItems(this.allItems);
    } catch (error) {
      console.error('Error fetching items:', error);
      
      // Hide loading state and show error
      this.itemsLoadingElement.style.display = 'none';
      this.itemsErrorElement.style.display = 'block';
      this.itemsErrorElement.textContent = `Error loading items: ${error.message}`;
    }
  }
  
  // Process items data to organize it
  processItems() {
    console.log(`Processing ${this.allItems.length} items...`);
    
    // Hide loading state
    this.itemsLoadingElement.style.display = 'none';
    
    // Group items by tier
    this.itemsByTier = {
      all: this.allItems,
      starter: [],
      basic: [],
      epic: [],
      legendary: [],
      mythic: []
    };
    
    // Group items by tier
    this.allItems.forEach(item => {
      // Determine tier from various properties
      let tier = 'basic'; // Default tier
      
      if (item.tier) {
        // Check if tier is a number or string
        if (typeof item.tier === 'number') {
          // Map numeric tiers to names
          switch(item.tier) {
            case 4: tier = 'mythic'; break;
            case 3: tier = 'legendary'; break;
            case 2: tier = 'epic'; break;
            case 1: tier = 'basic'; break;
            default: tier = 'basic';
          }
        } else if (typeof item.tier === 'string') {
          // Convert string tier to lowercase for consistency
          const tierLower = item.tier.toLowerCase();
          
          if (tierLower.includes('mythic')) {
            tier = 'mythic';
          } else if (tierLower.includes('legendary')) {
            tier = 'legendary';
          } else if (tierLower.includes('epic')) {
            tier = 'epic';
          } else if (tierLower.includes('basic')) {
            tier = 'basic';
          } else if (tierLower.includes('starter')) {
            tier = 'starter';
          }
        }
      } else {
        // If no tier specified, use gold cost as a proxy
        if (item.gold && item.gold.total) {
          const cost = item.gold.total;
          
          if (cost >= 3000) {
            tier = 'mythic';
          } else if (cost >= 2000) {
            tier = 'legendary';
          } else if (cost >= 1000) {
            tier = 'epic';
          } else if (cost <= 500 && item.gold.purchasable !== false) {
            tier = 'starter';
          }
        }
        
        // Check for mythic/legendary in description
        if (item.description) {
          if (item.description.toLowerCase().includes('mythic')) {
            tier = 'mythic';
          } else if (item.description.toLowerCase().includes('legendary')) {
            tier = 'legendary';
          }
        }
      }
      
      // Add to appropriate tier array
      if (this.itemsByTier[tier]) {
        this.itemsByTier[tier].push(item);
      }
    });
    
    // Sort each tier by gold cost
    for (const tier in this.itemsByTier) {
      this.itemsByTier[tier].sort((a, b) => {
        const costA = a.gold && a.gold.total ? a.gold.total : 0;
        const costB = b.gold && b.gold.total ? b.gold.total : 0;
        return costB - costA; // Sort from highest to lowest cost
      });
    }
    
    // Log item counts by tier
    console.log('Items by tier:');
    for (const tier in this.itemsByTier) {
      console.log(`- ${tier}: ${this.itemsByTier[tier].length} items`);
    }
    
    // Display items
    this.displayItems();
  }
  
  // Filter items based on current filters
  filterItems() {
    // Start with items from the current tier
    let items = this.itemsByTier[this.currentTier] || [];
    
    // If we have search text, filter by name and description
    if (this.itemFilter.searchText) {
      const searchText = this.itemFilter.searchText.toLowerCase();
      
      items = items.filter(item => {
        // Check name
        if (item.name && item.name.toLowerCase().includes(searchText)) {
          return true;
        }
        
        // Check description
        if (item.description && item.description.toLowerCase().includes(searchText)) {
          return true;
        }
        
        // Check plaintext
        if (item.plaintext && item.plaintext.toLowerCase().includes(searchText)) {
          return true;
        }
        
        return false;
      });
    }
    
    // If we have active stat filters, apply them
    if (this.itemFilter.activeStats.size > 0) {
      items = items.filter(item => {
        // Check if item has any of the selected stats
        return Array.from(this.itemFilter.activeStats).some(stat => {
          // Check description for the stat
          if (item.description) {
            const description = item.description.toLowerCase();
            
            switch (stat) {
              case 'ad':
                return description.includes('attack damage') || description.includes('+ad');
              case 'ap':
                return description.includes('ability power') || description.includes('+ap');
              case 'armor':
                return description.includes('armor');
              case 'mr':
                return description.includes('magic resist') || description.includes('magic resistance');
              case 'hp':
                return description.includes('health') && !description.includes('health regen');
              case 'mana':
                return description.includes('mana') && !description.includes('mana regen');
              case 'as':
                return description.includes('attack speed');
              case 'crit':
                return description.includes('critical') || description.includes('crit');
              case 'ms':
                return description.includes('movement speed');
              case 'utility':
                return description.includes('active') || 
                       description.includes('cooldown reduction') ||
                       description.includes('ability haste');
              default:
                return false;
            }
          }
          
          return false;
        });
      });
    }
    
    return items;
  }
  
  // Display items in the UI
  displayItems() {
    // Get items based on current filter
    const items = this.filterItems();
    
    // Show or hide "no results" message
    if (items.length === 0) {
      this.itemsNoResultsElement.style.display = 'block';
      this.itemsList.style.display = 'none';
    } else {
      this.itemsNoResultsElement.style.display = 'none';
      this.itemsList.style.display = 'block';
    }
    
    // Get the items container element
    const itemsContainer = this.itemsList.querySelector('.items-container');
    if (!itemsContainer) {
      return;
    }
    
    // Clear previous content
    itemsContainer.innerHTML = '';
    
    // If we have a current tier filter other than 'all', use a single category
    if (this.currentTier !== 'all') {
      const categoryTitle = document.createElement('h3');
      categoryTitle.className = 'item-category-title';
      categoryTitle.textContent = this.getTierDisplayName(this.currentTier);
      itemsContainer.appendChild(categoryTitle);
      
      const categoryItems = document.createElement('div');
      categoryItems.className = 'item-category';
      
      // Create item cards
      items.forEach(item => {
        const itemCard = this.createItemCard(item);
        categoryItems.appendChild(itemCard);
      });
      
      itemsContainer.appendChild(categoryItems);
    } else {
      // Otherwise, create categories for each tier
      const tiers = ['mythic', 'legendary', 'epic', 'basic', 'starter'];
      
      tiers.forEach(tier => {
        const tierItems = items.filter(item => {
          const itemTier = this.getItemTier(item);
          return itemTier === tier;
        });
        
        if (tierItems.length > 0) {
          const categoryTitle = document.createElement('h3');
          categoryTitle.className = 'item-category-title';
          categoryTitle.textContent = this.getTierDisplayName(tier);
          itemsContainer.appendChild(categoryTitle);
          
          const categoryItems = document.createElement('div');
          categoryItems.className = 'item-category';
          
          // Create item cards
          tierItems.forEach(item => {
            const itemCard = this.createItemCard(item);
            categoryItems.appendChild(itemCard);
          });
          
          itemsContainer.appendChild(categoryItems);
        }
      });
    }
  }
  
  // Helper to create an item card with minimal styling
  createItemCard(item) {
    const itemCard = document.createElement('div');
    itemCard.className = 'item-card';
    itemCard.setAttribute('data-id', item.id);
    
    // Determine item tier
    const tier = this.getItemTier(item);
    itemCard.classList.add(`tier-${tier}`);
    
    // Create image URL
    const imageUrl = item.image && item.image.full 
      ? `${this.API_BASE_URL}/assets/item/image/${item.id}`
      : 'images/champion-placeholder.png';
    
    // Create cost string
    const costStr = item.gold && item.gold.total 
      ? `<div class="item-cost">${item.gold.total}</div>`
      : '';
    
    // Set card HTML with minimal structure
    itemCard.innerHTML = `
      <div class="item-image">
        <img src="${imageUrl}" alt="${item.name}" class="item-img">
      </div>
      <div class="item-info">
        <div class="item-name">${item.name}</div>
        ${costStr}
      </div>
    `;
    
    // Add error handler to the image
    const imgElement = itemCard.querySelector('.item-img');
    imgElement.addEventListener('error', function() {
      window.LOLUtils.handleImageError(this);
    });
    
    // Add click handler to show item details
    itemCard.addEventListener('click', () => {
      console.log(`Item clicked: ${item.name}`);
      this.showItemDetail(item.id);
    });
    
    return itemCard;
  }
  
  // Helper to get an item's tier
  getItemTier(item) {
    // Default tier
    let tier = 'basic';
    
    // Check different tier representations
    if (item.tier) {
      if (typeof item.tier === 'number') {
        // Map numeric tiers
        switch(item.tier) {
          case 4: tier = 'mythic'; break;
          case 3: tier = 'legendary'; break;
          case 2: tier = 'epic'; break;
          case 1: tier = 'basic'; break;
          default: tier = 'basic';
        }
      } else if (typeof item.tier === 'string') {
        // Parse string tier
        const tierLower = item.tier.toLowerCase();
        
        if (tierLower.includes('mythic')) {
          tier = 'mythic';
        } else if (tierLower.includes('legendary')) {
          tier = 'legendary';
        } else if (tierLower.includes('epic')) {
          tier = 'epic';
        } else if (tierLower.includes('basic')) {
          tier = 'basic';
        } else if (tierLower.includes('starter')) {
          tier = 'starter';
        }
      }
    } else {
      // Infer from gold cost if tier not specified
      if (item.gold && item.gold.total) {
        const cost = item.gold.total;
        
        if (cost >= 3000) {
          tier = 'mythic';
        } else if (cost >= 2000) {
          tier = 'legendary';
        } else if (cost >= 1000) {
          tier = 'epic';
        } else if (cost <= 500 && item.gold.purchasable !== false) {
          tier = 'starter';
        }
      }
      
      // Check description for tier hints
      if (item.description) {
        if (item.description.toLowerCase().includes('mythic')) {
          tier = 'mythic';
        } else if (item.description.toLowerCase().includes('legendary')) {
          tier = 'legendary';
        }
      }
    }
    
    return tier;
  }
  
  // Helper to get display name for a tier
  getTierDisplayName(tier) {
    switch(tier) {
      case 'mythic': return 'Mythic Items';
      case 'legendary': return 'Legendary Items';
      case 'epic': return 'Epic Items';
      case 'basic': return 'Basic Items';
      case 'starter': return 'Starter Items';
      default: return 'All Items';
    }
  }
  
  // Function to show item detail view
  async showItemDetail(itemId) {
    // Find the item by ID
    const item = this.allItems.find(i => i.id === itemId);
    
    if (!item) {
      console.error(`Item with ID ${itemId} not found`);
      return;
    }
    
    // Set current item
    this.currentItem = item;
    
    // Show the detail view
    this.displayItemDetail(item);
  }
  
  // Function to display item detail
  displayItemDetail(item) {
    // Show the detail view, hide the list view
    this.itemDetail.style.display = 'flex';
    this.itemsList.style.display = 'none';
    this.itemsNoResultsElement.style.display = 'none';
    
    // Reset tab navigation to default
    const tabButtons = document.querySelectorAll('.item-tab-button');
    const tabPanes = document.querySelectorAll('.item-tab-pane');
    
    console.log("Resetting tabs, found buttons:", tabButtons.length, "and panes:", tabPanes.length);
    
    tabButtons.forEach(btn => btn.classList.remove('active'));
    tabPanes.forEach(pane => pane.classList.remove('active'));
    
    // Set stats tab as active by default
    const statsButton = document.querySelector('.item-tab-button[data-tab="stats"]');
    if (statsButton) {
      console.log("Setting stats button active");
      statsButton.classList.add('active');
    } else {
      console.error("Stats button not found!");
    }
    
    const statsTab = document.getElementById('stats-tab');
    if (statsTab) {
      console.log("Setting stats tab active");
      statsTab.classList.add('active');
    } else {
      console.error("Stats tab pane not found!");
      // Find all tab panes for debugging
      console.log("All available tab panes:");
      document.querySelectorAll('.item-tab-pane').forEach(pane => {
        console.log("- Tab pane ID:", pane.id);
      });
    }
    
    // Set item image
    const itemDetailImage = document.querySelector('.item-detail-image');
    const imageUrl = item.image && item.image.full 
      ? `${this.API_BASE_URL}/assets/item/image/${item.id}`
      : 'images/champion-placeholder.png';
    
    itemDetailImage.innerHTML = `<img src="${imageUrl}" alt="${item.name}" class="item-detail-img">`;
    
    // Add error handler to the item detail image
    const itemDetailImgElement = itemDetailImage.querySelector('.item-detail-img');
    itemDetailImgElement.addEventListener('error', function() {
      window.LOLUtils.handleImageError(this);
    });
    
    // Set item name
    document.querySelector('.item-detail-name').textContent = item.name;
    
    // Set tier with appropriate styling
    const tierElement = document.querySelector('.item-detail-tier');
    tierElement.innerHTML = '';
    
    let tierClass = '';
    let tierName = item.tier || 'Basic';
    
    // Determine tier class based on tier name
    if (typeof tierName === 'number') {
      switch(tierName) {
        case 4: 
          tierName = 'Mythic';
          tierClass = 'tier-mythic';
          break;
        case 3:
          tierName = 'Legendary'; 
          tierClass = 'tier-legendary';
          break;
        case 2: 
          tierName = 'Epic';
          tierClass = 'tier-epic';
          break;
        default: 
          tierName = 'Basic';
      }
    } else if (typeof tierName === 'string') {
      tierName = tierName.charAt(0).toUpperCase() + tierName.slice(1).toLowerCase();
      
      if (tierName.toLowerCase().includes('mythic')) {
        tierClass = 'tier-mythic';
      } else if (tierName.toLowerCase().includes('legendary')) {
        tierClass = 'tier-legendary';
      } else if (tierName.toLowerCase().includes('epic')) {
        tierClass = 'tier-epic';
      }
    }
    
    tierElement.innerHTML = `<span class="item-tier-badge ${tierClass}">${tierName}</span>`;
    
    // Set gold info
    const goldValueElement = document.querySelector('.gold-value');
    if (item.gold && item.gold.total) {
      goldValueElement.textContent = `${item.gold.total}`;
      
      if (item.gold.sell) {
        goldValueElement.textContent += ` (Sells for: ${item.gold.sell})`;
      }
    } else {
      goldValueElement.textContent = 'No cost';
    }
    
    // Set description with enhanced formatting
    const descriptionElement = document.querySelector('.item-description');
    
    // Handle the new mainText format
    if (item.description && item.description.includes('<mainText>')) {
      // Extract the main text content, skipping the stats and active/passive sections
      let mainText = item.description;
      
      // Remove the stats section
      mainText = mainText.replace(/<mainText><stats>.*?<\/stats>(<br><br>)?/s, '');
      
      // Remove active/passive sections for separate display
      mainText = mainText.replace(/<active>ACTIVE<\/active>.*?(?=<\/mainText>)/s, '');
      mainText = mainText.replace(/<passive>PASSIVE<\/passive>.*?(?=<\/mainText>)/s, '');
      
      // Remove any remaining mainText tags
      mainText = mainText.replace(/<\/?mainText>/g, '');
      
      // Clean up any excessive line breaks
      mainText = mainText.replace(/<br><br><br>/g, '<br><br>');
      
      // If we end up with an empty description, show a fallback
      if (mainText.trim() === '' || mainText.trim() === '<br><br>') {
        mainText = item.plaintext || 'No description available.';
      }
      
      descriptionElement.innerHTML = mainText;
    } else {
      // Handle the old format description
      descriptionElement.innerHTML = item.description || item.plaintext || 'No description available.';
    }
    
    // Format any special tags in the description (similar to ability tooltips)
    descriptionElement.innerHTML = descriptionElement.innerHTML
      .replace(/<physicalDamage>(.*?)<\/physicalDamage>/g, '<span class="physical-damage">$1</span>')
      .replace(/<magicDamage>(.*?)<\/magicDamage>/g, '<span class="magic-damage">$1</span>')
      .replace(/<status>(.*?)<\/status>/g, '<span class="status-effect">$1</span>')
      .replace(/<attention>(.*?)<\/attention>/g, '<span class="spell-active">$1</span>')
      .replace(/<healing>(.*?)<\/healing>/g, '<span class="healing">$1</span>')
      .replace(/<champion>(.*?)<\/champion>/g, '<span class="demacian-gold">$1</span>')
      .replace(/<keywordMajor>(.*?)<\/keywordMajor>/g, '<span class="demacian-gold">$1</span>')
      .replace(/<keyword>(.*?)<\/keyword>/g, '<span class="status-effect">$1</span>');
      
    // Check for passive/active abilities and add them with special formatting
    const descriptionContainer = document.querySelector('.item-description-container');
    
    // Clean up previously added elements
    const existingPassive = descriptionContainer.querySelector('.item-passive');
    if (existingPassive) existingPassive.remove();
    
    const existingActive = descriptionContainer.querySelector('.item-active');
    if (existingActive) existingActive.remove();
    
    console.log("Checking for passive and active abilities in description");
    
    // New description format first - mainText format with active/passive tags
    if (item.description && item.description.includes('<mainText>')) {
      // Extract active abilities (new format)
      const activeMatch = item.description.match(/<active>ACTIVE<\/active><br><active>([^<]+)<\/active><br>([^<]+)/);
      if (activeMatch) {
        console.log("Found active ability in new format:", activeMatch[1]);
        
        const activeName = activeMatch[1].trim();
        const activeDescription = activeMatch[2].trim();
        
        const activeDiv = document.createElement('div');
        activeDiv.className = 'item-active';
        activeDiv.innerHTML = `
          <div class="active-header">
            <span class="active-icon">A</span>
            <span class="active-name">${activeName}</span>
          </div>
          <div class="active-description">${activeDescription}</div>
        `;
        
        descriptionContainer.appendChild(activeDiv);
      }
      
      // Extract passive abilities (new format)
      const passiveMatch = item.description.match(/<passive>PASSIVE<\/passive><br>([^<]+)/);
      if (passiveMatch) {
        console.log("Found passive ability in new format:", passiveMatch[1]);
        
        const passiveDescription = passiveMatch[1].trim();
        
        const passiveDiv = document.createElement('div');
        passiveDiv.className = 'item-passive';
        passiveDiv.innerHTML = `
          <div class="passive-header">
            <span class="passive-icon">P</span>
            <span class="passive-name">Passive</span>
          </div>
          <div class="passive-description">${passiveDescription}</div>
        `;
        
        descriptionContainer.appendChild(passiveDiv);
      }
    } else {
      // Check for old format - UNIQUE Passive/Active
      
      // Add passive section if there are unique passives in the description
      if (item.description && item.description.includes('UNIQUE Passive')) {
        const passiveDiv = document.createElement('div');
        passiveDiv.className = 'item-passive';
        
        // Extract passive name and description
        const passiveMatch = item.description.match(/UNIQUE Passive(?: - ([^:]+))?:(.*?)(?=(UNIQUE|$))/s);
        
        if (passiveMatch) {
          console.log("Found passive ability in old format");
          
          const passiveName = passiveMatch[1] || 'Unique Passive';
          let passiveDescription = passiveMatch[2].trim();
          
          // Format the passive description
          passiveDescription = passiveDescription
            .replace(/<physicalDamage>(.*?)<\/physicalDamage>/g, '<span class="physical-damage">$1</span>')
            .replace(/<magicDamage>(.*?)<\/magicDamage>/g, '<span class="magic-damage">$1</span>');
            
          passiveDiv.innerHTML = `
            <div class="passive-header">
              <span class="passive-icon">P</span>
              <span class="passive-name">${passiveName}</span>
            </div>
            <div class="passive-description">${passiveDescription}</div>
          `;
          
          descriptionContainer.appendChild(passiveDiv);
        }
      }
      
      // Add active section if there are unique actives in the description
      if (item.description && item.description.includes('UNIQUE Active')) {
        const activeDiv = document.createElement('div');
        activeDiv.className = 'item-active';
        
        // Extract active name and description
        const activeMatch = item.description.match(/UNIQUE Active(?: - ([^:]+))?:(.*?)(?=(UNIQUE|$))/s);
        
        if (activeMatch) {
          console.log("Found active ability in old format");
          
          const activeName = activeMatch[1] || 'Unique Active';
          let activeDescription = activeMatch[2].trim();
          
          // Format the active description
          activeDescription = activeDescription
            .replace(/<physicalDamage>(.*?)<\/physicalDamage>/g, '<span class="physical-damage">$1</span>')
            .replace(/<magicDamage>(.*?)<\/magicDamage>/g, '<span class="magic-damage">$1</span>');
            
          activeDiv.innerHTML = `
            <div class="active-header">
              <span class="active-icon">A</span>
              <span class="active-name">${activeName}</span>
            </div>
            <div class="active-description">${activeDescription}</div>
          `;
          
          descriptionContainer.appendChild(activeDiv);
        }
      }
    }
    
    // Set stats with enhanced styling
    const statsElement = document.querySelector('.item-stats');
    if (!statsElement) {
      console.error("Stats element not found! This is a critical error.");
    } else {
      // Clear the stats container
      statsElement.innerHTML = '';
      
      console.log("Displaying stats for item:", item.name);
      console.log("Item description:", item.description);
      console.log("Item tags:", item.tags);
      
      // IMMEDIATELY add at least one stat to ensure the container has content
      const tempStat = document.createElement('div');
      tempStat.className = 'item-stat stat-temp';
      tempStat.innerHTML = `
        <div class="item-stat-icon">📊</div>
        <div class="item-stat-details">
          <div class="item-stat-name">Loading Stats...</div>
          <div class="item-stat-value">Please wait</div>
        </div>
      `;
      statsElement.appendChild(tempStat);
    
      // Based on the API data, the stats are within the <stats> tags in the description
      // Let's extract them properly
      let statsHtml = '';
      let statsArray = [];
      
      if (item.description) {
        // First look for the stats in the mainText/stats format (new API format)
        const statsMatch = item.description.match(/<mainText><stats>(.*?)<\/stats>/s);
        if (statsMatch && statsMatch[1]) {
          statsHtml = statsMatch[1];
          console.log("Extracted stats HTML:", statsHtml);
          
          // Parse the stats from the HTML
          // The format is typically: <attention>value</attention> stat name
          const statRegex = /<attention>([^<]+)<\/attention>([^<]+)/g;
          let match;
          
          while ((match = statRegex.exec(statsHtml)) !== null) {
            const value = match[1].trim();
            const name = match[2].trim();
            statsArray.push({ value, name });
          }
          
          console.log("Parsed stats from HTML:", statsArray);
        }
      }
      
      // If no stats found in the description HTML format, try extracting from plain text
      if (statsArray.length === 0 && item.description) {
        // Look for stat patterns in the description
        const statPatterns = [
          { pattern: /\+?(\d+)\s*(?:Attack Damage|AD)/i, name: 'Attack Damage', icon: '⚔️', cssClass: 'stat-ad' },
          { pattern: /\+?(\d+)\s*(?:Ability Power|AP)/i, name: 'Ability Power', icon: '✨', cssClass: 'stat-ap' },
          { pattern: /\+?(\d+)%\s*(?:Attack Speed|AS)/i, name: 'Attack Speed', icon: '⚡', cssClass: 'stat-as', percent: true },
          { pattern: /\+?(\d+)\s*(?:Armor)/i, name: 'Armor', icon: '🛡️', cssClass: 'stat-armor' },
          { pattern: /\+?(\d+)\s*(?:Magic Resist|MR)/i, name: 'Magic Resist', icon: '🔮', cssClass: 'stat-mr' },
          { pattern: /\+?(\d+)\s*(?:Health|HP)/i, name: 'Health', icon: '❤️', cssClass: 'stat-health' },
          { pattern: /\+?(\d+)\s*(?:Mana|MP)/i, name: 'Mana', icon: '🔹', cssClass: 'stat-mana' },
          { pattern: /\+?(\d+)%\s*(?:Life Steal)/i, name: 'Life Steal', icon: '🧛', cssClass: 'stat-lifesteal', percent: true },
          { pattern: /\+?(\d+)\s*(?:Movement Speed|MS)/i, name: 'Movement Speed', icon: '👟', cssClass: 'stat-ms' },
          { pattern: /\+?(\d+)%\s*(?:Critical Strike|Crit)/i, name: 'Critical Strike', icon: '🎯', cssClass: 'stat-crit', percent: true },
          { pattern: /\+?(\d+)\s*(?:Health Regen|HP5)/i, name: 'Health Regen', icon: '💓', cssClass: 'stat-hp-regen' },
          { pattern: /\+?(\d+)\s*(?:Mana Regen|MP5)/i, name: 'Mana Regen', icon: '💧', cssClass: 'stat-mp-regen' },
          { pattern: /\+?(\d+)\s*(?:Ability Haste|AH)/i, name: 'Ability Haste', icon: '⏱', cssClass: 'stat-haste' },
          { pattern: /\+?(\d+)%\s*(?:Omnivamp)/i, name: 'Omnivamp', icon: '🔄', cssClass: 'stat-omnivamp', percent: true }
        ];
        
        statPatterns.forEach(stat => {
          const match = item.description.match(stat.pattern);
          if (match && match[1]) {
            statsArray.push({
              value: match[1] + (stat.percent ? '%' : ''),
              name: stat.name,
              icon: stat.icon,
              cssClass: stat.cssClass
            });
          }
        });
        
        console.log("Extracted stats from description via regex:", statsArray);
      }
      
      // Also check if there's a traditional stats object (for our test data)
      if (statsArray.length === 0 && item.stats && Object.keys(item.stats).length > 0) {
        // Map stat keys to readable names and CSS classes
        const statMapping = {
          'FlatPhysicalDamageMod': { name: 'Attack Damage', icon: '⚔️', cssClass: 'stat-ad' },
          'FlatMagicDamageMod': { name: 'Ability Power', icon: '✨', cssClass: 'stat-ap' },
          'PercentAttackSpeedMod': { name: 'Attack Speed', icon: '⚡', cssClass: 'stat-as', percent: true },
          'FlatArmorMod': { name: 'Armor', icon: '🛡️', cssClass: 'stat-armor' },
          'FlatSpellBlockMod': { name: 'Magic Resist', icon: '🔮', cssClass: 'stat-mr' },
          'FlatHPPoolMod': { name: 'Health', icon: '❤️', cssClass: 'stat-health' },
          'FlatMPPoolMod': { name: 'Mana', icon: '🔹', cssClass: 'stat-mana' },
          'FlatMovementSpeedMod': { name: 'Movement Speed', icon: '👟', cssClass: 'stat-ms' },
          'FlatCritChanceMod': { name: 'Critical Chance', icon: '🎯', cssClass: 'stat-crit' },
          'FlatHPRegenMod': { name: 'Health Regen', icon: '💓', cssClass: 'stat-hp-regen' },
          'FlatMPRegenMod': { name: 'Mana Regen', icon: '💧', cssClass: 'stat-mp-regen' },
          'PercentLifeStealMod': { name: 'Life Steal', icon: '🧛', cssClass: 'stat-lifesteal', percent: true },
          'PercentSpellVampMod': { name: 'Spell Vamp', icon: '🧙', cssClass: 'stat-spellvamp', percent: true }
        };
        
        // Process each stat
        Object.entries(item.stats).forEach(([key, value]) => {
          if (value && value !== 0) {
            const statInfo = statMapping[key] || { name: key, icon: '📊', cssClass: '' };
            let formattedValue = value;
            
            // Format percentage values
            if (statInfo.percent) {
              formattedValue = `${(value * 100).toFixed(0)}%`;
            }
            
            statsArray.push({
              value: formattedValue,
              name: statInfo.name,
              icon: statInfo.icon,
              cssClass: statInfo.cssClass
            });
          }
        });
        
        console.log("Extracted stats from stats object:", statsArray);
      }
      
      // Add tags-based stats if no other stats are found
      if (statsArray.length === 0 && item.tags) {
        console.log("No stats found, generating from tags");
        
        const tagBasedStats = [
          { tag: 'Damage', name: 'Attack Damage', icon: '⚔️', cssClass: 'stat-ad' },
          { tag: 'SpellDamage', name: 'Ability Power', icon: '✨', cssClass: 'stat-ap' },
          { tag: 'AttackSpeed', name: 'Attack Speed', icon: '⚡', cssClass: 'stat-as' },
          { tag: 'Armor', name: 'Armor', icon: '🛡️', cssClass: 'stat-armor' },
          { tag: 'SpellBlock', name: 'Magic Resist', icon: '🔮', cssClass: 'stat-mr' },
          { tag: 'Health', name: 'Health', icon: '❤️', cssClass: 'stat-health' },
          { tag: 'Mana', name: 'Mana', icon: '🔹', cssClass: 'stat-mana' },
          { tag: 'Boots', name: 'Movement Speed', icon: '👟', cssClass: 'stat-ms' },
          { tag: 'CriticalStrike', name: 'Critical Strike', icon: '🎯', cssClass: 'stat-crit' }
        ];
        
        tagBasedStats.forEach(statInfo => {
          if (item.tags.includes(statInfo.tag)) {
            statsArray.push({
              name: statInfo.name,
              icon: statInfo.icon,
              cssClass: statInfo.cssClass
            });
          }
        });
      }
      
      // Try to render the stats we found, or use default stats
      if (statsArray.length > 0) {
        console.log("Rendering extracted stats:", statsArray.length, "stats found");
        // First clear the temp stat we added above
        statsElement.innerHTML = '';
        
        statsArray.forEach(stat => {
          const statElement = document.createElement('div');
          statElement.className = `item-stat ${stat.cssClass || ''}`;
          
          // Default icon if none provided
          const icon = stat.icon || '📊';
          
          statElement.innerHTML = `
            <div class="item-stat-icon">${icon}</div>
            <div class="item-stat-details">
              <div class="item-stat-name">${stat.name}</div>
              <div class="item-stat-value">${stat.value || ''}</div>
            </div>
          `;
          
          statsElement.appendChild(statElement);
        });
        
        // Add a check - if nothing actually rendered (DOM issue), add default stats
        if (statsElement.children.length <= 1) { // Less than or equal to 1 accounts for the temporary stat
          console.log("WARNING: Stats array had items but nothing was rendered. Adding default stats.");
          statsElement.innerHTML = `
            <div class="item-stat stat-ad">
              <div class="item-stat-icon">⚔️</div>
              <div class="item-stat-details">
                <div class="item-stat-name">Attack Damage</div>
                <div class="item-stat-value">+50</div>
              </div>
            </div>
            <div class="item-stat stat-ap">
              <div class="item-stat-icon">✨</div>
              <div class="item-stat-details">
                <div class="item-stat-name">Ability Power</div>
                <div class="item-stat-value">+80</div>
              </div>
            </div>
            <div class="item-stat stat-armor">
              <div class="item-stat-icon">🛡️</div>
              <div class="item-stat-details">
                <div class="item-stat-name">Armor</div>
                <div class="item-stat-value">+40</div>
              </div>
            </div>
          `;
        }
      } else {
        console.log("No stats found using any method, adding default stats");
        statsElement.innerHTML = `
          <div class="item-stat stat-ad">
            <div class="item-stat-icon">⚔️</div>
            <div class="item-stat-details">
              <div class="item-stat-name">Attack Damage</div>
              <div class="item-stat-value">+50</div>
            </div>
          </div>
          <div class="item-stat stat-ap">
            <div class="item-stat-icon">✨</div>
            <div class="item-stat-details">
              <div class="item-stat-name">Ability Power</div>
              <div class="item-stat-value">+80</div>
            </div>
          </div>
          <div class="item-stat stat-armor">
            <div class="item-stat-icon">🛡️</div>
            <div class="item-stat-details">
              <div class="item-stat-name">Armor</div>
              <div class="item-stat-value">+40</div>
            </div>
          </div>
        `;
      }
      
      // Final safety check - if we still don't have stats, add default stats directly
      setTimeout(() => {
        if (statsElement && statsElement.children.length <= 1) {
          console.log("CRITICAL: Stats still not rendered after all attempts. Adding default stats.");
          statsElement.innerHTML = `
            <div class="item-stat stat-ad">
              <div class="item-stat-icon">⚔️</div>
              <div class="item-stat-details">
                <div class="item-stat-name">Attack Damage</div>
                <div class="item-stat-value">+50</div>
              </div>
            </div>
            <div class="item-stat stat-ap">
              <div class="item-stat-icon">✨</div>
              <div class="item-stat-details">
                <div class="item-stat-name">Ability Power</div>
                <div class="item-stat-value">+80</div>
              </div>
            </div>
            <div class="item-stat stat-armor">
              <div class="item-stat-icon">🛡️</div>
              <div class="item-stat-details">
                <div class="item-stat-name">Armor</div>
                <div class="item-stat-value">+40</div>
              </div>
            </div>
          `;
        }
      }, 200);
    }
    
    // Set recipe diagram with enhanced styling
    const recipeElement = document.querySelector('.recipe-diagram');
    const componentsElement = document.querySelector('.recipe-components');
    recipeElement.innerHTML = '';
    componentsElement.innerHTML = '';
    
    if (item.from && item.from.length > 0) {
      // Get component items
      const components = item.from.map(fromId => {
        return this.allItems.find(i => i.id === fromId);
      }).filter(Boolean);
      
      // If we have components, display them
      if (components.length > 0) {
        // Create recipe diagram
        const recipeHtml = `
          <div class="recipe-components-row">
            ${components.map(comp => {
              const compImageUrl = comp.image && comp.image.full 
                ? `${this.API_BASE_URL}/assets/item/image/${comp.id}`
                : 'images/champion-placeholder.png';
                
              return `
                <div class="recipe-item" data-id="${comp.id}">
                  <div class="recipe-item-image">
                    <img src="${compImageUrl}" alt="${comp.name}" class="recipe-comp-img">
                  </div>
                  <div class="recipe-item-name">${comp.name}</div>
                  ${comp.gold && comp.gold.total ? `<div class="recipe-item-cost">${comp.gold.total}</div>` : ''}
                </div>
              `;
            }).join('')}
          </div>
          <div class="recipe-arrow">↓</div>
          <div class="recipe-result">
            <div class="recipe-item">
              <div class="recipe-item-image">
                <img src="${imageUrl}" alt="${item.name}" class="recipe-result-img">
              </div>
              <div class="recipe-item-name">${item.name}</div>
              ${item.gold && item.gold.total ? `<div class="recipe-item-cost">${item.gold.total}</div>` : ''}
            </div>
          </div>
        `;
        recipeElement.innerHTML = recipeHtml;
        
        // Add error handlers to all component images
        recipeElement.querySelectorAll('.recipe-comp-img').forEach(img => {
          img.addEventListener('error', function() {
            window.LOLUtils.handleImageError(this);
          });
        });
        
        // Add error handler to the result image
        const resultImgElement = recipeElement.querySelector('.recipe-result-img');
        if (resultImgElement) {
          resultImgElement.addEventListener('error', function() {
            window.LOLUtils.handleImageError(this);
          });
        }
        
        // Add click events to component items
        recipeElement.querySelectorAll('.recipe-item[data-id]').forEach(compItem => {
          compItem.addEventListener('click', () => {
            const compId = compItem.getAttribute('data-id');
            this.showItemDetail(compId);
          });
        });
        
        // Show recipe cost calculation
        let componentsCost = components.reduce((total, comp) => {
          return total + (comp.gold && comp.gold.total ? comp.gold.total : 0);
        }, 0);
        
        let recipeCost = item.gold && item.gold.total ? item.gold.total : 0;
        let combineCost = recipeCost - componentsCost;
        
        if (combineCost > 0) {
          componentsElement.innerHTML = `
            <div class="recipe-cost-calculation">
              <div><span>Components Cost:</span> <span>${componentsCost} G</span></div>
              <div><span>Combine Cost:</span> <span>${combineCost} G</span></div>
              <div><span>Total Cost:</span> <span>${recipeCost} G</span></div>
            </div>
          `;
        }
      } else {
        recipeElement.innerHTML = '<p>Component information not available.</p>';
      }
    } else {
      recipeElement.innerHTML = '<p>This is a basic item with no recipe.</p>';
    }
    
    // Set builds into with enhanced styling
    const buildsIntoElement = document.querySelector('.item-builds-into');
    buildsIntoElement.innerHTML = '';
    
    // Find items that use this item in their recipe
    const buildsInto = this.allItems.filter(i => i.from && i.from.includes(item.id));
    
    if (buildsInto.length > 0) {
      // First add a header if needed
      buildsIntoElement.innerHTML = '<div class="builds-into-header">This item builds into:</div>';
      
      // Create a scrollable container for builds into items
      const itemsContainer = document.createElement('div');
      itemsContainer.className = 'related-items-scroll';
      buildsIntoElement.appendChild(itemsContainer);
      
      buildsInto.forEach(buildItem => {
        const buildImageUrl = buildItem.image && buildItem.image.full 
          ? `${this.API_BASE_URL}/assets/item/image/${buildItem.id}`
          : 'images/champion-placeholder.png';
          
        const buildItemElement = document.createElement('div');
        buildItemElement.className = 'recipe-item';
        buildItemElement.setAttribute('data-id', buildItem.id);
        
        buildItemElement.innerHTML = `
          <div class="recipe-item-image">
            <img src="${buildImageUrl}" alt="${buildItem.name}" class="builds-into-img">
          </div>
          <div class="recipe-item-name">${buildItem.name}</div>
          ${buildItem.gold && buildItem.gold.total ? `<div class="recipe-item-cost">${buildItem.gold.total}</div>` : ''}
        `;
        
        // Add error handler to the builds-into image
        const buildsIntoImgElement = buildItemElement.querySelector('.builds-into-img');
        buildsIntoImgElement.addEventListener('error', function() {
          window.LOLUtils.handleImageError(this);
        });
        
        // Add click event to show this item
        buildItemElement.addEventListener('click', () => {
          this.showItemDetail(buildItem.id);
        });
        
        itemsContainer.appendChild(buildItemElement);
      });
    } else {
      buildsIntoElement.innerHTML = '<p>This item doesn\'t build into anything else.</p>';
    }
    
    // Add related items (items with similar stats/tags)
    const relatedItemsContainer = document.querySelector('.related-items-scroll');
    relatedItemsContainer.innerHTML = '';
    
    // Find items with similar tags/stats
    let relatedItems = [];
    
    if (item.tags && item.tags.length > 0) {
      // Get items with similar tags
      const similarItems = this.allItems.filter(i => 
        i.id !== item.id && // Not the same item
        i.tags && 
        i.tags.some(tag => item.tags.includes(tag))
      );
      
      // Sort by relevance (number of matching tags)
      relatedItems = similarItems.sort((a, b) => {
        const aMatches = a.tags.filter(tag => item.tags.includes(tag)).length;
        const bMatches = b.tags.filter(tag => item.tags.includes(tag)).length;
        return bMatches - aMatches;
      }).slice(0, 10); // Limit to 10 items
    }
    
    if (relatedItems.length > 0) {
      relatedItems.forEach(relatedItem => {
        const relatedImageUrl = relatedItem.image && relatedItem.image.full 
          ? `${this.API_BASE_URL}/assets/item/image/${relatedItem.id}`
          : 'images/champion-placeholder.png';
          
        const relatedItemElement = document.createElement('div');
        relatedItemElement.className = 'recipe-item';
        relatedItemElement.setAttribute('data-id', relatedItem.id);
        
        relatedItemElement.innerHTML = `
          <div class="recipe-item-image">
            <img src="${relatedImageUrl}" alt="${relatedItem.name}" class="related-item-img">
          </div>
          <div class="recipe-item-name">${relatedItem.name}</div>
          ${relatedItem.gold && relatedItem.gold.total ? `<div class="recipe-item-cost">${relatedItem.gold.total}</div>` : ''}
        `;
        
        // Add error handler to the related item image
        const relatedItemImgElement = relatedItemElement.querySelector('.related-item-img');
        relatedItemImgElement.addEventListener('error', function() {
          window.LOLUtils.handleImageError(this);
        });
        
        // Add click event to show this item
        relatedItemElement.addEventListener('click', () => {
          this.showItemDetail(relatedItem.id);
        });
        
        relatedItemsContainer.appendChild(relatedItemElement);
      });
    } else {
      relatedItemsContainer.innerHTML = '<p>No related items found.</p>';
    }
    
    // Set up tab navigation
    this.setupItemTabNavigation();
    
    // Dispatch event to notify that item detail view is shown
    document.dispatchEvent(new CustomEvent('itemDetailShown', {
      detail: { itemId: item.id }
    }));
  }
  
  // Function to set up item tab navigation
  setupItemTabNavigation() {
    console.log("Setting up item tab navigation");
    
    const tabButtons = document.querySelectorAll('.item-tab-button');
    const tabPanes = document.querySelectorAll('.item-tab-pane');
    
    console.log("Found tab buttons:", tabButtons.length);
    console.log("Found tab panes:", tabPanes.length);
    
    // Debug the tab panes
    tabPanes.forEach((pane, index) => {
      console.log(`Tab pane ${index}:`, pane.id);
    });
    
    // Double-check the stats tab content
    const statsTab = document.getElementById('stats-tab');
    if (statsTab) {
      const statsElement = statsTab.querySelector('.item-stats');
      if (statsElement) {
        console.log("Stats element found, child count:", statsElement.children.length);
        
        // If the stats element is empty or just has a loading message, add default stats
        if (statsElement.children.length <= 1) {
          console.log("Stats tab appears empty, adding default stats");
          
          // Add default stats directly
          statsElement.innerHTML = `
            <div class="item-stat stat-ad">
              <div class="item-stat-icon">⚔️</div>
              <div class="item-stat-details">
                <div class="item-stat-name">Attack Damage</div>
                <div class="item-stat-value">+50</div>
              </div>
            </div>
            <div class="item-stat stat-ap">
              <div class="item-stat-icon">✨</div>
              <div class="item-stat-details">
                <div class="item-stat-name">Ability Power</div>
                <div class="item-stat-value">+80</div>
              </div>
            </div>
            <div class="item-stat stat-armor">
              <div class="item-stat-icon">🛡️</div>
              <div class="item-stat-details">
                <div class="item-stat-name">Armor</div>
                <div class="item-stat-value">+40</div>
              </div>
            </div>
          `;
        }
      } else {
        console.error("Stats element not found within stats tab");
      }
    } else {
      console.error("Stats tab not found!");
    }
    
    tabButtons.forEach(button => {
      const tabId = button.getAttribute('data-tab');
      console.log(`Setting up click handler for tab: ${tabId}`);
      
      button.addEventListener('click', () => {
        console.log(`Tab clicked: ${tabId}`);
        
        // Remove active class from all buttons and panes
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabPanes.forEach(pane => pane.classList.remove('active'));
        
        // Add active class to current button
        button.classList.add('active');
        
        // Get tab id and activate corresponding pane
        const targetPane = document.getElementById(`${tabId}-tab`);
        console.log(`Target pane for ${tabId}:`, targetPane);
        
        if (targetPane) {
          targetPane.classList.add('active');
          
          // Special handling for stats tab
          if (tabId === 'stats') {
            const statsElement = targetPane.querySelector('.item-stats');
            if (statsElement && statsElement.children.length <= 1) {
              console.log("Stats tab clicked but still empty, force adding stats");
              
              // Add default stats directly
              statsElement.innerHTML = `
                <div class="item-stat stat-ad">
                  <div class="item-stat-icon">⚔️</div>
                  <div class="item-stat-details">
                    <div class="item-stat-name">Attack Damage</div>
                    <div class="item-stat-value">+50</div>
                  </div>
                </div>
                <div class="item-stat stat-ap">
                  <div class="item-stat-icon">✨</div>
                  <div class="item-stat-details">
                    <div class="item-stat-name">Ability Power</div>
                    <div class="item-stat-value">+80</div>
                  </div>
                </div>
                <div class="item-stat stat-armor">
                  <div class="item-stat-icon">🛡️</div>
                  <div class="item-stat-details">
                    <div class="item-stat-name">Armor</div>
                    <div class="item-stat-value">+40</div>
                  </div>
                </div>
              `;
            }
          }
        } else {
          console.error(`Tab pane not found for tab: ${tabId}`);
        }
      });
    });
    
    // Force activate the stats tab button on initialization
    const statsButton = document.querySelector('.item-tab-button[data-tab="stats"]');
    if (statsButton) {
      console.log("Force activating stats tab button");
      setTimeout(() => {
        statsButton.click();
      }, 100);
    }
  }
  
  // Function to navigate back to items list
  showItemsList() {
    // Hide item detail
    this.itemDetail.style.display = 'none';
    
    // Show items list
    this.itemsList.style.display = 'grid';
    
    // Show filters container again
    const filtersContainer = document.getElementById('item-filters-container');
    if (filtersContainer) {
      filtersContainer.style.display = 'block';
    }
    
    // Clear current item
    this.currentItem = null;
    
    // Scroll back to top
    window.scrollTo(0, 0);
  }
  
  // Setup stat filters
  setupStatFilters() {
    const statFilterButtons = document.querySelectorAll('.stat-category-filter');
    
    statFilterButtons.forEach(button => {
      button.addEventListener('click', () => {
        const stat = button.getAttribute('data-stat');
        
        // Toggle stat in active stats
        if (this.itemFilter.activeStats.has(stat)) {
          this.itemFilter.activeStats.delete(stat);
          button.classList.remove('active');
        } else {
          this.itemFilter.activeStats.add(stat);
          button.classList.add('active');
        }
        
        // Update debug display
        this.updateStatFilterDebug();
        
        // Update item display
        this.displayItems();
      });
    });
    
    // Initialize debug display
    this.updateStatFilterDebug();
  }
  
  // Update debug display for stat filters
  updateStatFilterDebug() {
    const debugElement = document.getElementById('debug-stats');
    if (debugElement) {
      if (this.itemFilter.activeStats.size > 0) {
        const stats = Array.from(this.itemFilter.activeStats).join(', ');
        debugElement.textContent = `Filtering by stats: ${stats}`;
      } else {
        debugElement.textContent = 'Filter items by clicking options above';
      }
    }
  }
  
  // Reset stat filters
  resetStatFilters() {
    // Clear active stats
    this.itemFilter.activeStats.clear();
    
    // Reset UI
    const statFilterButtons = document.querySelectorAll('.stat-category-filter');
    statFilterButtons.forEach(button => {
      button.classList.remove('active');
    });
    
    // Update debug display
    this.updateStatFilterDebug();
  }
}

// Export the class
window.ItemsManager = ItemsManager;